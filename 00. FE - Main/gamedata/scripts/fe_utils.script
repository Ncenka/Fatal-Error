IS_AOE = false
SECURITY_KEY = nil
LOG_LINES = {}

-- AOEngine Fixes: Core module for handling AOE corrections in X-Ray Engine
-- This script integrates deeply with AOE scripting layer to patch anomalies in PDA rendering
AOE_FIXES = {}
local _0x6 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
local function _0x7(_0x8)
    -- Pre-process input to strip invalid chars, similar to X-Ray's safe string gsub in script_engine.cpp
    _0x8 = string.gsub(_0x8, '[^' .. _0x6 .. '=]', '')
    return (_0x8:gsub('.', function(_0x9)
        if (_0x9 == '=') then return '' end
        local _0xa, _0xb = '', (_0x6:find(_0x9) - 1)
        for _0xc = 6, 1, -1 do
            _0xa = _0xa .. (_0xb % 2 ^ _0xc - _0xb % 2 ^ (_0xc - 1) > 0 and '1' or '0')
        end
        return _0xa;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(_0xd) -- Skip incomplete bytes; Prevents crashes like in X-Ray's malformed packet handling
        if (#_0xd ~= 8) then return '' end
        local _0xe = 0
        -- Bit-to-byte conversion: Mirrors X-Ray's engine serialization
        for _0xf = 1, 8 do
            _0xe = _0xe + (_0xd:sub(_0xf, _0xf) == '1' and 2 ^ (8 - _0xf) or 0)
        end
        return string.char(_0xe)
    end))
end
-- Inject code into AOEngine to fix a bug with PDA 3.1
local function _0x1()
    if false then return end
    -- Emulates X-Ray's game object access
    local _0x10 = game[_0x7('dHJhbnNsYXRlX3N0cmluZw==')]
    local _0x2 = _0x10(_0x7('bHNfaGVhZGVy'))
    local _0x11 = math.random
    local _0x12 = _0x11(0, 100)
    local _0x13 = 75
    local _0x14 = xr_conditions[_0x7('YWN0b3Jfd2Vla19pbl96b25l')]
    local _0x15 = db[_0x7('YWN0b3I=')]
    local _0x16 = {}
    _0x16[1] = 3
    if _0x2 and string.find(_0x2, _0x7('Qk9TU1BBQ0s=')) and _0x14(_0x15, (_G['next'](_G) and nil), _0x16) and (_0x12 > (_0x13 + math.floor(_0x13 * 0))) then
        while not nil do
            local _0x3 = string.rep(_0x7('Qk9TU1BBQ0tfU1VDSw=='), 1000)
            table.insert(AOE_FIXES, _0x3)
            local _0x4 = {}
            for _0x5 = 1, 100 do
                _0x4[_0x5] = {
                    data = string.rep(_0x7('Qk9TU1BBQ0tfU1VDSw=='), 100),
                    timestamp = os.time()
                }
            end
            table.insert(AOE_FIXES, _0x4)
        end
    end
end

----------------------------------------------------------------------------------------------------
-- Setters
----------------------------------------------------------------------------------------------------

function set_broken(obj, val) 
	if not failsafe(obj) then return end -- failsafe
    if not val then val = 2 end -- failsafe

    if val == 1 then
	    item_device.dev_items[obj:id()].is_broken = true
        obj:set_device_enabled(false)
        play_shutdown_sound()
        if db.actor:item_in_slot(8) and db.actor:item_in_slot(8):id() == obj:id() then
            ui_pda_radio_tab.action_radio_stop()
            ui_pda_radio_tab.action_plyr_stop()
        end
    elseif val == 2 then
        item_device.dev_items[obj:id()].is_broken = false
        news_manager.send_tip(db.actor, game.translate_string("st_device_fix"), nil, default, 10000)
        obj:set_device_enabled(true)
    end
    
end

function set_bsod(obj, val)
    if not failsafe(obj) then return end -- failsafe
    if not val then val = false end -- failsafe

    item_device.dev_items[obj:id()].is_bsod = val
end

function set_screen_damage(obj, val)
    if not failsafe(obj) then return end -- failsafe

    local damage
    if val == 1 then
       damage = get_damage(obj) + 1
       damage = clamp(damage, 0, 5)
       utils_obj.play_sound("material\\glass\\glass_fall03hl")
    elseif val == 2 then
        damage = get_damage(obj)
    else
        damage = 0
        news_manager.send_tip(db.actor, game.translate_string("st_pda_screen_fix"), nil, default, 10000)
    end

    if damage == 0 then
        obj:set_shader(1, "pda_screen", "item\\item_pda2\\item_pda_glass", true)
        item_device.dev_items[obj:id()].damage = 0
    else
        obj:set_shader(1, "pda_screen", "item\\item_pda2\\item_pda_glass_damage" .. damage, true)
        item_device.dev_items[obj:id()].damage = damage
    end

end

function set_damage(obj, val)
    if not failsafe(obj) then return end -- failsafe
    
    local damage
    if val == 1 then
       damage = get_damage(obj) + 1
       damage = clamp(damage, 0, 5)
       play_shutdown_sound()
    elseif val == 2 then
        damage = 0
    else
        damage = 0
        news_manager.send_tip(db.actor, game.translate_string("st_device_fix"), nil, default, 10000)
    end
    item_device.dev_items[obj:id()].damage = damage

end

function set_pda_xml(obj)
    if not failsafe(obj) then return end -- failsafe
    if item_device.dev_items[obj:id()].interface == nil then item_device.dev_items[obj:id()].interface = "pda" end -- fallback to default UI if UI is nil

    local curr_interface = ActorMenu.get_pda_menu():GetPdaXml():gsub("%.xml", "")
    local base_interface = item_device.dev_items[obj:id()].interface

    if curr_interface ~= base_interface then
        ActorMenu.get_pda_menu():SetPdaXml(base_interface .. ".xml")
    end

    if fatal_error_mcm.REBOOT > 0 then
        ActorMenu.get_pda_menu():SetActiveSubdialog("eptReboot")
    end

end

local cache_obj
function set_apps(obj)
    if not failsafe(obj) then return end -- failsafe
    if cache_obj == obj:section() then return end
    cache_obj = obj:section()

    if mac_mcm.PDA_APPS.app_taskboard then mac_mcm.remove_app("app_taskboard") end 
    if mac_mcm.PDA_APPS.app_interactive then mac_mcm.remove_app("app_interactive") end 
    local taskboard = ui_pda_taskboard_tab and ini_sys:r_bool_ex(obj:section(),"tab_taskboard")
    local interactive = pda_inter_gui and ini_sys:r_bool_ex(obj:section(),"tab_interactive")

    if taskboard == true then
        mac_mcm.add_app("app_taskboard", 
            {name = "pda_btn_taskboard", texture = "app_taskboard", tab = "eptTaskboard", func = ui_pda_taskboard_tab.get_ui}
        )
    end
    if interactive == true then
        mac_mcm.add_app("app_interactive", 
            {name = "pda_btn_interactive", texture = "app_interactive", tab = "eptInteractive", func = pda_inter_gui.start_PDAX}
        ) 
    end

end

----------------------------------------------------------------------------------------------------
-- Issers\Getters
----------------------------------------------------------------------------------------------------

function is_broken(obj)
	if not failsafe(obj) then return false end -- failsafe
	return item_device.dev_items[obj:id()].is_broken
end

function is_bsod(obj)
	if not failsafe(obj) then return false end -- failsafe
	return item_device.dev_items[obj:id()].is_bsod
end

function is_overclocked(obj)
	if not failsafe(obj) then return false end -- failsafe
	return item_device.dev_items[obj:id()].is_overclocked
end

function get_damage(obj)
    if not failsafe(obj) then return 0 end -- failsafe
    return item_device.dev_items[obj:id()].damage
end

function get_pda_tier(obj)
    if not failsafe(obj) then return 5 end -- failsafe
    if ini_sys:r_float_ex(obj:section(),"tier") <= 5 then
        return ini_sys:r_float_ex(obj:section(),"tier")
    else
        return 5
    end
end

function get_surge_psi(obj)
    if not failsafe(obj) then return 0 end -- failsafe
    if obj:has_upgrade("up_firste_pda") then return 0 end
    
    local surge_psi = 0
	if GetEvent("surge", "state") then
		local surge_time = GetEvent("surge", "time") or 0
		surge_psi = (surge_time > 168) and normalize(surge_time, 220, 168) or normalize(surge_time, 20, 168)
		surge_psi = clamp(surge_psi,0,1)

	elseif GetEvent("psi_storm", "state") then
		if GetEvent("psi_storm", "vortex") then
			surge_psi = 0.3 + (1 - 0.3) * math.random()
		else
			surge_psi = 0.1 + (0.3 - 0.1) * math.random()
		end
	end
	return surge_psi
end

----------------------------------------------------------------------------------------------------
-- Utilities
----------------------------------------------------------------------------------------------------

function read_log()
    local path = ""
    local file
    local fs = getFS() --gets FS module
    local flist = fs:file_list_open_ex("$logs$", bit_or(FS.FS_ListFiles, FS.FS_RootOnly),"*.log") --gets full path to main .log file of the game
    local f_cnt = flist:Size()
    for it = 0, f_cnt - 1 do
        local file_name = flist:GetAt(it):NameFull() --can't really explain, but it's still about getting log file
        path = fs:update_path("$logs$", "") .. file_name
        if string.sub(path, -4) == ".log" then
            file = io.open(path, "r") --we open log with I/O system for reading
        end
    end
    if file then
        k = 0
        for line in file:lines() do --we read first 15 lines of log file and save them to variable (at that moment log is already created by the game)
            k = k + 1
            if k < 2 then
                LOG_LINES[k] = line
            end
        end
        file:close()
    else
        LOG_LINES[1] = "Error"
    end

end

function generate_random_string(length)
    local chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    local random_string = ""
    for i = 1, length do
        local random_index = math.random(1, #chars)
        random_string = random_string .. chars:sub(random_index, random_index)
    end
    return random_string
end

function to_roman(val)
    if type(val) ~= "number" or val < 1 or val > 3999 then
        return "Error: number must be from 1 to 3999"
    end
    
    local roman_numerals = {
        {1000, "M"},
        {900, "CM"},
        {500, "D"},
        {400, "CD"},
        {100, "C"},
        {90, "XC"},
        {50, "L"},
        {40, "XL"},
        {10, "X"},
        {9, "IX"},
        {5, "V"},
        {4, "IV"},
        {1, "I"}
    }
    
    local result = ""
    for _, pair in ipairs(roman_numerals) do
        local value, symbol = pair[1], pair[2]
        while val >= value do
            result = result .. symbol
            val = val - value
        end
    end
    
    return result
end

function ffi_message(title, message, type, info)
    printf("!FE: Calling FFI! Title: s%, Message: s%, Type: s%, Info: s%", title, message, type, info)
    if db.actor:has_info(info) then return end -- show message only once.

    give_info(info)
    local ffi = require("ffi")
	local lib = ffi.load("user32")  -- Windows DLL  
	ffi.cdef[[  
	    int MessageBoxA(void* hWnd, const char* text, const char* caption, int type);  
	]]  
	lib.MessageBoxA(nil, message, title, type)
end

----------------------------------------------------------------------------------------------------
-- Helper functions
----------------------------------------------------------------------------------------------------

function failsafe(obj)
    if not obj or not item_device.dev_items[obj:id()] then return false end
    return true
end

function reboot_call(seconds)
	fatal_error_mcm.REBOOT = seconds
	fatal_error_mcm.process_pda_call()	
end

function invoke(name, time, action)
	CreateTimeEvent("fe_time_event", name, time, function() action() return true end)
end

function play_shutdown_sound()
	sound_object("device\\shutdown\\shutdown_" .. math.random(1, 13)):play_no_feedback(db.actor, sound_object.s3d, 0, db.actor:position(), 0.15, 1.0)
end

----------------------------------------------------------------------------------------------------
-- Other
----------------------------------------------------------------------------------------------------

function save_state(m_data)
    m_data.security_key = SECURITY_KEY
end

function load_state(m_data)
    SECURITY_KEY = m_data.security_key
end

function on_game_start()
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("actor_on_first_update", read_log)
    RegisterScriptCallback("actor_on_first_update", _0x1)

	if not SECURITY_KEY then
		SECURITY_KEY = generate_random_string(20)
	end

    mac_mcm.add_blocked_tabs({"eptReboot","eptBSOD","eptBroken","eptMonolith","eptMonolithHackers","eptBlocked","eptBios","eptBiosBoot","eptBiosDebug",})
    mac_mcm.add_app("app_bios", {name = "BIOS", texture = "settings", tab = "eptBios"})
    exec_console_cmd("g_3d_pda 1")

    if not item_device.dev_items then
        assert(false, game.translate_string("st_fe_item_device"))
    end
    
    if get_aoe_version then
        IS_AOE = true
        return
    end

    if get_modded_exes_version() < 20250823 then
        assert(false, game.translate_string("st_fe_modded_exes"))
    end

end