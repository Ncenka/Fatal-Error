--test ver
SETTINGS = {
    pda = {
        emission = {5, 4, 3, 2, 1},
        electra = {25, 20, 15, 10, 5},
        radiation = {1, 0.75, 0.50, 0.25, 0.10},
        bsod = {25, 20, 15, 10, 5}
	},
    devices = {
        emission = 5,
        electra = 15,
        radiation = 0.10
    },
	other = {
		devices_unreliability = 1,
		damage_chance = 2,
		break_head_device = 5,
		reboot_min_time = 30,
		reboot_max_time = 60,
		shutdown_min_time = 5,
		shutdown_max_time = 10,
		beep_radius = 50,
        radiation = {
            amount_to_fry = 1,
            glitch_scale = 0.1,
            scale = 1,
            amount_lower = 0.01,
        },
    },
	reboot_key = DIK_keys.DIK_M,
	light_reboot = false,
}

local delays = {
    emission = 60,
	radiation = 1,
	bsod = 60,
	shutdown = 5,
}

REBOOT = 0
local reboot_protection = 0
RADIATION_AMOUNT = 0
ELECTRA_GLITCH_VALUE = 0

----------------------------------------------------------------------------------------------------
-- Mod Configuration Menu
----------------------------------------------------------------------------------------------------

function on_mcm_load()
	options = { 
		id = "fatal_error", gr= {
			{id = "fe_pdas", sh = true, gr= {
				{ id = "pda0_emission", type="track", val = 2, min = 0, max = 100, step = 1, def = 5 },
				{ id = "pda1_emission", type="track", val = 2, min = 0, max = 100, step = 1, def = 4 },
				{ id = "pda2_emission", type="track", val = 2, min = 0, max = 100, step = 1, def = 3 },
				{ id = "pda3_emission", type="track", val = 2, min = 0, max = 100, step = 1, def = 2 },
				{ id = "pda4_emission", type="track", val = 2, min = 0, max = 100, step = 1, def = 1 },
				{ id = "pda0_electra", type="track", val = 2, min = 0, max = 100, step = 1, def = 25 },
				{ id = "pda1_electra", type="track", val = 2, min = 0, max = 100, step = 1, def = 20 },
				{ id = "pda2_electra", type="track", val = 2, min = 0, max = 100, step = 1, def = 15 },
				{ id = "pda3_electra", type="track", val = 2, min = 0, max = 100, step = 1, def = 10 },
				{ id = "pda4_electra", type="track", val = 2, min = 0, max = 100, step = 1, def = 5 },
				{ id = "pda0_radiation", type="track", val = 2, min = 0, max = 1, step = 0.01, def = 1 },
				{ id = "pda1_radiation", type="track", val = 2, min = 0, max = 1, step = 0.01, def = 0.75 },
				{ id = "pda2_radiation", type="track", val = 2, min = 0, max = 1, step = 0.01, def = 0.50 },
				{ id = "pda3_radiation", type="track", val = 2, min = 0, max = 1, step = 0.01, def = 0.25 },
				{ id = "pda4_radiation", type="track", val = 2, min = 0, max = 1, step = 0.01, def = 0.10 },
				{ id = "pda0_bsod", type="track", val = 2, min = 0, max = 100, step = 1, def = 25 },
				{ id = "pda1_bsod", type="track", val = 2, min = 0, max = 100, step = 1, def = 20 },
				{ id = "pda2_bsod", type="track", val = 2, min = 0, max = 100, step = 1, def = 15 },
				{ id = "pda3_bsod", type="track", val = 2, min = 0, max = 100, step = 1, def = 10 },
				{ id = "pda4_bsod", type="track", val = 2, min = 0, max = 100, step = 1, def = 5 },
			},},
			{id = "fe_devices", sh = true, gr= {
				{ id = "devices_emission", type="track", val = 2, min = 0, max = 100, step = 1, def = 5 },
				{ id = "devices_electra", type="track", val = 2, min = 0, max = 100, step = 1, def = 15 },
				{ id = "devices_radiation", type="track", val = 2, min = 0, max = 1, step = 0.01, def = 0.10 },
			},},
			{id = "fe_other", sh = true, gr= {
				{ id = "devices_unreliability", type="track", val = 2, min = 0, max = 100, step = 1, def = 1 },
				{ id = "emission_delay", type="track", val = 2, min = 10, max = 120, step = 10, def = 60 },
				{ id = "radiation_delay", type="track", val = 2, min = 1, max = 60, step = 1, def = 1 },
				{ id = "radiation_glitch_scale", type="track", val = 2, min = 0, max = 1, step = 0.01, def = 0.1 },
				{ id = "radiation_scale", type="track", val = 2, min = 0, max = 10, step = 0.01, def = 1 },
				{ id = "radiation_amount_lower", type="track", val = 2, min = 0, max = 1, step = 0.01, def = 0.01 },
				{ id = "radiation_amount_to_fry", type="track", val = 2, min = 1, max = 5, step = 0.5, def = 1 },
				{ id = "chance_for_pda_to_damage", type="track", val = 2, min = 0, max = 100, step = 1, def = 2 },
				{ id = "chance_for_device_to_break", type="track", val = 2, min = 0, max = 100, step = 1, def = 5 },
				{ id = "reboot_time_min", type="track", val = 2, min = 0, max = 600, step = 10, def = 30 },
				{ id = "reboot_time_max", type="track", val = 2, min = 0, max = 600, step = 10, def = 60 },
				{ id = "shutdown_min_time", type="track", val = 2, min = 0, max = 60, step = 1, def = 5 },
				{ id = "shutdown_max_time", type="track", val = 2, min = 0, max = 60, step = 1, def = 10 },
				{ id = "beep_radius", type="track", val = 2, min = 5, max = 100, step = 1, def = 50 },
				{ id = "reboot_key", type = "key_bind", val = 2, def = DIK_keys.DIK_M},
				{ id = "light_reboot", type = "check", val = 1, def = false},
			},},
		}
	}
		
	return options
end

function on_option_change()
	
	local pda_tiers = {"pda0", "pda1", "pda2", "pda3", "pda4"}
		
	for i, tier in ipairs(pda_tiers) do	
		SETTINGS.pda.emission[i] = ui_mcm.get("fatal_error/fe_pdas/"..tier.."_emission")
		SETTINGS.pda.electra[i] = ui_mcm.get("fatal_error/fe_pdas/"..tier.."_electra")
		SETTINGS.pda.radiation[i] = ui_mcm.get("fatal_error/fe_pdas/"..tier.."_radiation")
		SETTINGS.pda.bsod[i] = ui_mcm.get("fatal_error/fe_pdas/"..tier.."_bsod")
	end

	SETTINGS.devices.emission = ui_mcm.get("fatal_error/fe_devices/devices_emission")
	SETTINGS.devices.electra = ui_mcm.get("fatal_error/fe_devices/devices_electra")
	SETTINGS.devices.radiation = ui_mcm.get("fatal_error/fe_devices/devices_radiation")

	delays.emission = ui_mcm.get("fatal_error/fe_other/emission_delay")
	delays.radiation = ui_mcm.get("fatal_error/fe_other/radiation_delay")
		
	SETTINGS.other.devices_unreliability = ui_mcm.get("fatal_error/fe_other/devices_unreliability")
	SETTINGS.other.radiation.glitch_scale = ui_mcm.get("fatal_error/fe_other/radiation_glitch_scale")
	SETTINGS.other.radiation.amount_to_fry = ui_mcm.get("fatal_error/fe_other/radiation_amount_to_fry")
	SETTINGS.other.radiation.scale = ui_mcm.get("fatal_error/fe_other/radiation_scale")
	SETTINGS.other.radiation.amount_lower = ui_mcm.get("fatal_error/fe_other/radiation_amount_lower")
	SETTINGS.other.damage_chance = ui_mcm.get("fatal_error/fe_other/chance_for_pda_to_damage")
	SETTINGS.other.break_head_device = ui_mcm.get("fatal_error/fe_other/chance_for_device_to_break")
	SETTINGS.other.reboot_min_time = ui_mcm.get("fatal_error/fe_other/reboot_time_min")
	SETTINGS.other.reboot_max_time = ui_mcm.get("fatal_error/fe_other/reboot_time_max")
	SETTINGS.other.shutdown_min_time = ui_mcm.get("fatal_error/fe_other/shutdown_min_time")
	SETTINGS.other.shutdown_max_time = ui_mcm.get("fatal_error/fe_other/shutdown_max_time")
	SETTINGS.other.beep_radius = ui_mcm.get("fatal_error/fe_other/beep_radius")
	SETTINGS.reboot_key = ui_mcm.get("fatal_error/fe_other/reboot_key")
	SETTINGS.light_reboot = ui_mcm.get("fatal_error/fe_other/light_reboot")

end

----------------------------------------------------------------------------------------------------
-- Break Devices \ PDA
----------------------------------------------------------------------------------------------------

function break_device(damage_type, upgrade)

    local available_devices = {}
    
    local function inventory_iterator(actor, item)
        local section = item:section()
        if IsItem("device",section)
			and not fe_utils.is_broken(item)
			and ini_sys:r_bool_ex(section,"can_break") == true
			and not section:find("glowstick")
		then
            local has_upgrade = item:has_upgrade(upgrade)
            if not has_upgrade then
                table.insert(available_devices, item)
            end
        end
    end
    
    db.actor:iterate_inventory(inventory_iterator, db.actor)
    
    if #available_devices > 0 then

        local obj = available_devices[math.random(1, #available_devices)]
		local sec = obj:section()
		local chance
		local is_device

		if sec:find("device_pda_") then
			local tier = fe_utils.get_pda_tier(obj)
        	chance = SETTINGS.pda[damage_type][tier]
		else
			chance = SETTINGS.devices[damage_type]
			is_device = true
		end

		if fe_utils.is_overclocked(obj) then
           	chance = chance * 2
        end
        
        local radiation_scale = 1
        if damage_type == "radiation" then
            radiation_scale = math.floor(RADIATION_AMOUNT)
        end
        
        if math.random(0, 100) < (radiation_scale * chance) then

			if is_device and 75 > math.random(0, 100) and fe_utils.get_damage(obj) < 5 then
				fe_utils.set_damage(obj, 1)
			elseif is_device then
				fe_utils.set_broken(obj, 1)
				fe_utils.set_damage(obj, 2)
			else
				fe_utils.set_broken(obj, 1)
			end
				
			if damage_type == "radiation" then
				RADIATION_AMOUNT = RADIATION_AMOUNT * 0.50
			end
        end
    end
end

----------------------------------------------------------------------------------------------------
-- PDA Repairs
----------------------------------------------------------------------------------------------------

function check_pda()
	return db.actor:item_in_slot(8)
end

function fix_pda_check_pda()
	return fe_utils.is_broken(db.actor:item_in_slot(8))
end

function fix_pda(cost, first_speaker, second_speaker)
	fe_utils.set_broken(db.actor:item_in_slot(8), 2)
	dialogs.relocate_money_from_actor(first_speaker, second_speaker, cost)
	RADIATION_AMOUNT = 0
end

function fix_pda_check_bsod()
	return fe_utils.is_bsod(db.actor:item_in_slot(8))
end

function fix_pda_bsod(first_speaker, second_speaker)
	fe_utils.set_bsod(db.actor:item_in_slot(8), false)
	dialogs.relocate_money_from_actor(first_speaker, second_speaker, 2500)
end

function fix_pda_bsod_check_money()
	return mlr_utils.have_money(2500)
end

function fix_pda_screen_check()
	return fe_utils.get_damage(db.actor:item_in_slot(8)) > 0
end

function fix_pda_screen(first_speaker, second_speaker)
	fe_utils.set_screen_damage(db.actor:item_in_slot(8), 3)
	dialogs.relocate_money_from_actor(first_speaker, second_speaker, 5000)
end

function fix_pda_screen_check_money()
	return mlr_utils.have_money(5000)
end

function fix_pda_0_check_money()
	local pda = db.actor:item_in_slot(8)
	if pda:section():find("device_pda_0") then
		return mlr_utils.have_money(5000) and fe_utils.is_broken(pda)
	else
		return mlr_utils.have_item("always_true", 1)
	end
end

function fix_pda_1_check_money()
	local pda = db.actor:item_in_slot(8)
	if pda:section():find("device_pda_1") then
		return mlr_utils.have_money(10000) and fe_utils.is_broken(pda)
	else
		return mlr_utils.have_item("always_true", 1)
	end
end

function fix_pda_2_check_money()
	local pda = db.actor:item_in_slot(8)
	if pda:section():find("device_pda_2") then
		return mlr_utils.have_money(20000) and fe_utils.is_broken(pda)
	else
		return mlr_utils.have_item("always_true", 1)
	end
end

function fix_pda_3_check_money()
	local pda = db.actor:item_in_slot(8)
	if pda:section():find("device_pda_3") then
		return mlr_utils.have_money(40000) and fe_utils.is_broken(pda)
	else
		return mlr_utils.have_item("always_true", 1)
	end
end

function fix_pda0_give_money(first_speaker, second_speaker)
	fix_pda(5000, first_speaker, second_speaker)
end

function fix_pda1_give_money(first_speaker, second_speaker)
	fix_pda(10000, first_speaker, second_speaker)
end

function fix_pda2_give_money(first_speaker, second_speaker) 
	fix_pda(20000, first_speaker, second_speaker)
end

function fix_pda3_give_money(first_speaker, second_speaker) 
	fix_pda(40000, first_speaker, second_speaker)
end

function has_getac()
	return mlr_utils.have_item("itm_pda_getac", 1)
end

function check_money_25k()
	return mlr_utils.have_money(25000)
end

function decypher_getac(first_speaker, second_speaker)

	local pda = db.actor:object("itm_pda_getac")
	local battery = pda:condition()
	
	alife_release(pda)
	news_manager.relocate_item(db.actor, "out", pda:section())
	alife_create_item("device_pda_getac", db.actor, {cond = battery})	
	news_manager.relocate_item(db.actor, "in", "device_pda_getac")
	dialogs.relocate_money_from_actor(first_speaker, second_speaker, 25000) 
end

function getac_sell(first_speaker, second_speaker)
	local pda = db.actor:object("itm_pda_getac")
	alife_release(pda)
	news_manager.relocate_item(db.actor, "out", pda:section())
	dialogs.relocate_money_to_actor(first_speaker, second_speaker, 10000)
end

----------------------------------------------------------------------------------------------------
-- Drag Drop
----------------------------------------------------------------------------------------------------

function pda_repair_kit(obj_b, obj_d, slot_from, slot_to)

	local tool = obj_b:section()
	local is_broken_or_damaged = fe_utils.is_broken(obj_d) or fe_utils.get_damage(obj_d) > 0

	if is_broken_or_damaged and tool:find("tool_fix_pda") then
		if fe_utils.is_broken(obj_d) then
			fe_utils.set_broken(obj_d, 2)
		elseif obj_d:section():find("pda") then
			fe_utils.set_screen_damage(obj_d, 3)
		else
			fe_utils.set_damage(obj_d, 3)
		end
		alife_release(obj_b)
		actor_effects.play_item_fx("craft_dummy")
	end
end

function geiger_check_device(obj_b, obj_d, slot_from, slot_to)

	local is_geiger = obj_b:section():find("detector_geiger") and not fe_utils.is_broken(obj_b)
	local is_device = obj_d:section():find("device_") or obj_d:section():find("detector_")
	local radiation_show = math.floor(RADIATION_AMOUNT * 1000)
	local rad_unit = game.translate_string("st_msv")

	if is_device and is_geiger and obj_b:condition() > 0.05 then
		hide_hud_inventory()
		alife_process_item(obj_b:section(), obj_b:id(), {cond = obj_b:condition() - 0.01})
		actor_menu.set_msg(1, radiation_show .. " " .. rad_unit, 2)
		local snd = sound_object("detectors\\geiger_" .. math.random(8))
		snd:play(actor, 0, sound_object.s2d)
	end
end

----------------------------------------------------------------------------------------------------
-- Device \ PDA Electra Damage + BSOD + Screen Damage
----------------------------------------------------------------------------------------------------
test_trigger = 0
test_delay = 0
function actor_on_before_hit(s_hit, bone_id)

	tg = time_global()

	--Without this PDA will multiply if actor has been hit by shotgun or many times in a small period of time - spend 2 hours
	if test_trigger == 0 then
		test_delay = tg + 1000
		test_trigger = 1
	end
	
	local damage_type_physical = {
		[hit.explosion] = true,
		[hit.fire_wound] = true,
		[hit.strike] = true,
		[hit.wound] = true
	}

	local head_bones={
		[15] = true, 
		[16] = true, 
		[17] = true, 
		[18] = true
	}

	local head_device = db.actor:item_in_slot(10)
	if
		head_bones[bone_id]
		and damage_type_physical[s_hit.type]
		and head_device
		and not fe_utils.is_broken(head_device)
		and math.random(0, 100) < SETTINGS.other.break_head_device
	then
		if 25 > math.random(0 ,100) and fe_utils.get_damage(head_device) < 5 then
			fe_utils.set_damage(head_device, 1)
			utils_obj.play_sound("material\\glass\\glass_fall03hl")
		else
			fe_utils.set_broken(head_device, 1)
			fe_utils.set_damage(head_device, 2)
			utils_obj.play_sound("material\\glass\\glass_fall03hl")
		end
	end
	
	if damage_type_physical[s_hit.type] and math.random(0, 100) < SETTINGS.other.damage_chance then

		local available_devices = {}
		local function inventory_iterator(actor, item)
			local section = item:section()
			if IsItem("device",section) and section:find("device_pda_")
				and ini_sys:r_bool_ex(section,"can_break") == true
			then
				table.insert(available_devices, item)
			end
		end
    	db.actor:iterate_inventory(inventory_iterator, db.actor)

		if #available_devices > 0 then
        	local pda = available_devices[math.random(1, #available_devices)]
			if fe_utils.get_damage(pda) < 5 and (test_trigger == 1 and tg > test_delay) then
				fe_utils.set_screen_damage(pda, 1)
				test_trigger = 0 --Fucking ensure PDAs don't multiply!
			end
		end

	end
	
	if s_hit.type == hit.shock then
		break_device("electra","up_firstc_pda")
		process_shutdown()
		ELECTRA_GLITCH_VALUE = clamp(ELECTRA_GLITCH_VALUE + s_hit.power * 10, 0, 1)
	end
	
	if s_hit.type == hit.radiation then
		RADIATION_AMOUNT = clamp(RADIATION_AMOUNT + (s_hit.power * SETTINGS.other.radiation.scale), 0, 20)
	end
end

function pda_break_bsod()
	
	RemoveTimeEvent("fe_time_event", "pda_break_bsod")
	CreateTimeEvent("fe_time_event", "pda_break_bsod", delays.bsod, pda_break_bsod)
	
	if
		not (REBOOT > 0 or reboot_protection > 0)
		and (xr_conditions.surge_started() or psi_storm_manager.is_started())
	then 

		local available_devices = {}
		local function inventory_iterator(actor, item)
			local section = item:section()
			if IsItem("device",section) and section:find("device_pda_")
				and not fe_utils.is_broken(item)
				and ini_sys:r_bool_ex(section,"can_break") == true
			then
				table.insert(available_devices, item)
			end
		end
    	db.actor:iterate_inventory(inventory_iterator, db.actor)
	
		if #available_devices > 0 then

			local pda = available_devices[math.random(1, #available_devices)]
			local tier = fe_utils.get_pda_tier(pda)
			local chance = SETTINGS.pda.bsod[tier]
				
			if fe_utils.is_overclocked(pda) then
				chance = chance * 2
			end
				
			if (math.random(0, 100) < chance) then
				fe_utils.set_bsod(pda, true)
				process_pda_call()
			end
		end
	end
end

function pda_break_emission()

	RemoveTimeEvent("fe_time_event", "pda_break_emission")
	CreateTimeEvent("fe_time_event", "pda_break_emission", delays.emission, pda_break_emission)

	if xr_conditions.surge_started() or psi_storm_manager.is_started() then 
		break_device("emission","up_firste_pda")
	end
end

function pda_break_radiation()

	RemoveTimeEvent("fe_time_event", "pda_break_radiation")
	CreateTimeEvent("fe_time_event", "pda_break_radiation", delays.radiation, pda_break_radiation)

	if RADIATION_AMOUNT > SETTINGS.other.radiation.amount_to_fry then 
		break_device("radiation","up_firsta_pda")
	end
end

----------------------------------------------------------------------------------------------------
-- PDA Reboot
----------------------------------------------------------------------------------------------------

function reboot_action(dik)
	if dik == SETTINGS.reboot_key then
		local obj = db.actor:active_item()
		if obj then
			local sec = obj:section()
			if sec:find("device_pda_") and obj:condition() > 0.05 and not fe_utils.is_broken(obj) then
				REBOOT = math.random(SETTINGS.other.reboot_min_time, SETTINGS.other.reboot_max_time)
				alife_process_item(sec, obj:id(), {cond = obj:condition() - 0.01})
				utils_obj.play_sound("device\\pda\\pda_dead")
				obj:play_hud_motion("anm_empty", true, 1, 1, 0)
				
				game.only_allow_movekeys(true)
				fe_utils.invoke("control", 2, function() game.only_allow_movekeys(false) end)
				fe_utils.invoke("reboot", 1.6, function() process_pda_call() end)
			end
		end
	end
end

----------------------------------------------------------------------------------------------------
-- PDA Process Things
----------------------------------------------------------------------------------------------------

function process_pda_call()
	
	local error_tabs = {
		["eptReboot"] = true,
		["eptBSOD"] = true,
		["eptBroken"] = true,
		["eptMonolith"] = true,
		["eptMonolithHackers"] = true,
		["eptBlocked"] = true,
	}

	local bios_tabs = {
		["eptBios"] = true,
		["eptBiosBoot"] = true,
		["eptBiosDebug"] = true,
	}
	
	local monolith_hackers = {
		["l10u_bunker"] = true,
		["l12u_control_monolith"] = true,
		["l13u_warlab"] = true,
		["labx8"] = true,
		["l10_radar"] = true,
		["l11_hospital"] = true,
		["l13_generators"] = true,
		["l12_stancia_2"]  = true,
		["l12_stancia"] = true,
		["l11_pripyat"] = true,
		["pripyat"] = true,
	}

	local monolith = {
		["l12u_sarcofag"] = true,
	}
	
	local no_jaming_factions = {
		["monolith"] = true,
		["greh"] = true,
		["zombied"] = true,	
	}

	local player_faction = get_actor_true_community()
	local levelname = level.name()
	local tab = ActorMenu.get_pda_menu():GetActiveSection()
	local pda = db.actor:item_in_slot(8)
		
	if pda then
		
		fe_utils.set_apps(pda)
		fe_utils.set_pda_xml(pda)

		local show_player = ini_sys:r_float_ex(pda:section(),"show_player")
		level.map_remove_object_spot(0, "actor_location")
		level.map_remove_object_spot(0, "actor_location_p")
		process_companion_icons(false)

		local overclock = fe_utils.is_overclocked(pda)
		
		if overclock then
			show_player = 3
		end
		
		if show_player >= 1 then
			level.map_add_object_spot(0, "actor_location", "disable_hint")
		end
		
		if show_player >= 2 then
			level.map_add_object_spot(0, "actor_location_p", "disable_hint")
		end
		
		if show_player >= 3 then
			process_companion_icons(true) -- Companion icons
		end
		
		if ini_sys:r_bool_ex(pda:section(),"encrypted") then
			ActorMenu.get_pda_menu():SetActiveSubdialog("eptBlocked")
		
		elseif REBOOT > 0 then
			ActorMenu.get_pda_menu():SetActiveSubdialog("eptReboot")

		elseif bios_tabs[tab] then
			ActorMenu.get_pda_menu():SetActiveSubdialog(tab)
			
		elseif fe_utils.is_bsod(pda) then
			ActorMenu.get_pda_menu():SetActiveSubdialog("eptBSOD")
		
		elseif 
			not (reboot_protection > 0 or overclock) 
			and (xr_conditions.surge_started() or psi_storm_manager.is_started())
		then
			ActorMenu.get_pda_menu():SetActiveSubdialog("eptBroken")
		
		elseif monolith[levelname] and not overclock then
			ActorMenu.get_pda_menu():SetActiveSubdialog("eptMonolith")
		
		elseif 
			not (pda:has_upgrade("up_seconc_pda") or no_jaming_factions[player_faction] or overclock)
			and (monolith_hackers[levelname])
		then
			ActorMenu.get_pda_menu():SetActiveSubdialog("eptMonolithHackers")
			
		elseif error_tabs[tab] then
			ActorMenu.get_pda_menu():SetActiveSubdialog("eptTasks")
		end
	end
end

function process_pda_button(dik)
	local bind = dik_to_bind(dik)
	local pda = db.actor:item_in_slot(8)
	if (bind == key_bindings.kACTIVE_JOBS or bind == key_bindings.kCUSTOM20) and pda then
		process_pda_call()
	end
end

function process_pda_slot(obj)
	if obj:section():find("pda_") and not obj:section():find("itm_pda_") then	
		process_pda_call()
	end
end

--Took from Better PDA Progression
function process_companion_icons(enable)
	for id,v in pairs(axr_companions.non_task_companions) do
		if enable then
			level.map_add_object_spot(id, "ui_pda2_companion_location", "st_ui_pda_companion")
		else
			level.map_remove_object_spot(id, "ui_pda2_companion_location")
		end
	end
	
	for id,squad in pairs(axr_companions.companion_squads) do
		if squad then
			for k in squad:squad_members() do
				if enable then
					level.map_add_object_spot(k.id, "ui_pda2_companion_location", "st_ui_pda_companion")
				else
					level.map_remove_object_spot(k.id, "ui_pda2_companion_location")
				end
			end
		end
	end
end

--Took from Bart's Minimap
local prev_cnt = 0
function update_count()
	local cnt = 0
	local pos = db.actor:position()
	local pda = db.actor:item_in_slot(8)
	if pda and pda:condition() > 0.05 and db.actor:has_info("bios_can_beep") and not fe_utils.is_broken(pda) and not fe_utils.is_bsod(pda) then
		local can_beep = ini_sys:r_bool_ex(pda:section(),"can_beep")
		if can_beep == true then
			for i=1,#db.OnlineStalkers do
				local id = db.OnlineStalkers[i]
				local obj = db.storage[id] and db.storage[id].object or level.object_by_id(id)
				if obj and IsStalker(obj) and obj:alive() and (pos:distance_to(obj:position()) <= SETTINGS.other.beep_radius) then
					cnt = cnt + 1
					if (prev_cnt < cnt) then
						xr_effects.play_snd(db.actor, nil, {[1] = "beeping\\contact_1"})
					end
				end
			end
		end
		if (prev_cnt > cnt)then
			xr_effects.play_snd(db.actor, nil, {[1] = "beeping\\contact_2"})
		end
		-- show number if count is bigger than 1
		prev_cnt = cnt
	end
end

----------------------------------------------------------------------------------------------------
-- Shutdown
----------------------------------------------------------------------------------------------------

local cache_obj
function enable_or_disable(obj, chance)
	if not cache_obj then cache_obj = obj end
	if cache_obj:id() ~= obj:id() then cache_obj:set_device_enabled(true) cache_obj = obj end
	
	if math.random(0, 100) < chance then
		obj:set_device_enabled(false)
		fe_utils.play_shutdown_sound()
		CreateTimeEvent("fe_time_event", "process_shutdown", math.random(SETTINGS.other.shutdown_min_time, SETTINGS.other.shutdown_max_time), process_shutdown)
	else
		if obj:is_device_enabled() == false and not fe_utils.is_broken(obj) then
			obj:set_device_enabled(true)
		end
		CreateTimeEvent("fe_time_event", "process_shutdown", delays.shutdown, process_shutdown)
	end
end

function process_shutdown()
	RemoveTimeEvent("fe_time_event", "process_shutdown")
	local obj = db.actor:active_detector()
	if (not obj or fe_utils.get_damage(obj) == 0) and db.actor:active_item() and db.actor:active_item():section():find("device_pda_") then 
		obj = db.actor:active_item()
	elseif not obj then
		obj = db.actor:item_in_slot(9) or db.actor:item_in_slot(8)
	end

	if obj then
		local radiation_chance = not obj:has_upgrade("up_firsta_pda") and clamp(RADIATION_AMOUNT, 0, 10) * 5 or 0
		local damage_chance = fe_utils.get_damage(obj) * 10
		local surge_psi_chance = fe_utils.get_surge_psi(obj) * 10
		local electra_chance = not obj:has_upgrade("up_firstc_pda") and ELECTRA_GLITCH_VALUE * 50 or 0
		local final_chance = math.floor(radiation_chance + damage_chance + surge_psi_chance + electra_chance + SETTINGS.other.devices_unreliability)
		enable_or_disable(obj, final_chance)
	else
		CreateTimeEvent("fe_time_event", "process_shutdown", delays.shutdown, process_shutdown)
	end

end

----------------------------------------------------------------------------------------------------
-- Process every second
----------------------------------------------------------------------------------------------------

function on_every_second()

	RemoveTimeEvent("fe_time_event", "on_every_second")
	CreateTimeEvent("fe_time_event", "on_every_second", 1, on_every_second)

	if REBOOT > 0 then
		REBOOT = REBOOT - 1
		give_info("process_reboot")		
	elseif REBOOT == 0 and db.actor:has_info("process_reboot") then
		disable_info("process_reboot")
		reboot_protection = math.random(30, 60)
		process_pda_call()		
	elseif reboot_protection > 0 then
		reboot_protection = reboot_protection - 1
	end

	if RADIATION_AMOUNT > 0.01 then
		RADIATION_AMOUNT = RADIATION_AMOUNT - SETTINGS.other.radiation.amount_lower
	elseif RADIATION_AMOUNT < 0.01 then
		RADIATION_AMOUNT = 0
	end

end

----------------------------------------------------------------------------------------------------
-- Other
----------------------------------------------------------------------------------------------------

function actor_on_first_update()
	if not db.actor:has_info("fe_first_game_start") then
		REBOOT = 20
		give_info("fe_first_game_start")
		give_info("bios_can_beep")		
	end

	CreateTimeEvent("fe_time_event", "on_every_second", 1, on_every_second)
	CreateTimeEvent("fe_time_event", "pda_break_bsod", delays.bsod, pda_break_bsod)
	CreateTimeEvent("fe_time_event", "pda_break_radiation", delays.radiation, pda_break_radiation)
	CreateTimeEvent("fe_time_event", "pda_break_emission", delays.emission, pda_break_emission)
	CreateTimeEvent("fe_time_event", "process_shutdown", delays.shutdown, process_shutdown)

end

function save_state(m_data)
	m_data.RADIATION_AMOUNT = RADIATION_AMOUNT or 0
end

function load_state(m_data)
	RADIATION_AMOUNT = m_data.RADIATION_AMOUNT or 0
end

function reduce_radiation_on_sleep(hours)
    if RADIATION_AMOUNT > hours then
		RADIATION_AMOUNT = RADIATION_AMOUNT - hours
	else
		RADIATION_AMOUNT = 0
	end
end

function electra_glitch_lower()
	if ELECTRA_GLITCH_VALUE > 0.001 then
		ELECTRA_GLITCH_VALUE = ELECTRA_GLITCH_VALUE - 0.001
	else
		ELECTRA_GLITCH_VALUE = 0
	end
end

function on_game_start()

	RegisterScriptCallback("actor_on_update", electra_glitch_lower)
	RegisterScriptCallback("actor_on_update", update_count)

	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	RegisterScriptCallback("actor_on_first_update", process_pda_call)
	RegisterScriptCallback("actor_on_first_update", on_option_change)

	RegisterScriptCallback("ActorMenu_on_item_drag_drop", pda_repair_kit)
	RegisterScriptCallback("ActorMenu_on_item_drag_drop", geiger_check_device)

	RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
	RegisterScriptCallback("actor_on_before_hit", actor_on_before_hit)
	RegisterScriptCallback("on_key_press", reboot_action)
	RegisterScriptCallback("on_key_release", process_pda_button)
	RegisterScriptCallback("actor_item_to_slot", process_pda_slot)
	RegisterScriptCallback("on_option_change", on_option_change)
	RegisterScriptCallback("actor_on_sleep", reduce_radiation_on_sleep)
	
end